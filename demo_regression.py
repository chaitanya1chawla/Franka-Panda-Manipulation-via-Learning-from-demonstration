import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc
rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})
## for Palatino and other serif fonts use:
#rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)

import dmp

from dmp.dmp_cartesian import DMPs_cartesian as dmp
from dmp.rotation_matrix import roto_dilatation
import json


# Opening JSON file
#--> in the following lines, put the json file where you put your recorded trajectories (line 54 of webcam_pose_estimation.py)
with open('/home/dhrikarl/PycharmProjects/mediapipe/threeDPoseEstimation/myfile.json') as openfile:
    # Reading from json file
    json_object= json.load(openfile)

with open('/home/dhrikarl/PycharmProjects/mediapipe/threeDPoseEstimation/myfile2.json') as openfile2:
    json_object2= json.load(openfile2)

with open('/home/dhrikarl/PycharmProjects/mediapipe/threeDPoseEstimation/myfile3.json') as openfile3:
    json_object3= json.load(openfile3)

with open('/home/dhrikarl/PycharmProjects/mediapipe/threeDPoseEstimation/myfile4.json') as openfile4:
    json_object4 = json.load(openfile4)

#with open('/home/dhrikarl/PycharmProjects/mediapipe/threeDPoseEstimation/myfile5.json') as openfile5:
 #   json_object5 = json.load(openfile5)

#--> add all json_object s in the following list
json_objs=[ json_object,json_object2, json_object3, json_object4]


#--> change this also, according to the number of trajectories
num_traj = 4
traj_set = []
t_set = []
X=[]
points=[]
c=['green', 'blue', 'yellow', 'purple', 'black']
fig = plt.figure(figsize=(10, 7))
ax = plt.axes(projection="3d")
ax.view_init(elev=20, azim=60)

fig2 = plt.figure(figsize=(10, 7))
ax2 = plt.axes(projection="3d")
ax2.view_init(elev=20, azim=60)


# The trajectories will be generated by numerically integrating a dynamical
# system
'''
def fun(x):
    x1 = x[0]
    x2 = x[1]
    f1 = x1 ** 3 + x2 ** 2 * x1 - x1 - x2
        #x1**2 - x2
    f2 = x2 ** 3 + x1 ** 2 * x2 + x1 - x2
        #x2 ** 3 + x1 ** 2 * x2 + x1 - x2x2**2 - x1
    return np.array([f1, f2])
'''

'''
def RK4(x0, m, tf):
    # m x 2 matrix
    X = np.zeros([m, len(x0)])
    X[0] = x0.copy()
    dt = tf / (m - 1)
    #x also has 2 coordinates
    x = x0
    for n in range(m - 1):
        K1 = fun(x)
        K2 = fun(x + dt * K1 / 2.)
        K3 = fun(x + dt * K2 / 2.)
        K4 = fun(x + dt * K3)
        x += dt * (K1 + 2 * K2 + 2 * K3 + K4) / 6.
        X[n+1] = x
    return X
'''

for i in (range(num_traj)): #num_traj
    ## Random select x0, tf, and m
    theta = np.random.rand() * 2. * np.pi
    rho = 1. - np.random.rand() / 5.
    #starting point = x0, in x and y coordinates
    x0 = rho * np.array([np.cos(theta), np.sin(theta)])
    # tf has values between 5 and 7
    tf = 6. + 2. * (np.random.rand() - 0.5)
    m = int (500 + np.floor(500 * np.random.rand()))

    XYZ=json_objs[i]

    #t_set is array from 0 to tf with m steps
    t_set.append(np.linspace(0, tf, len(XYZ)))

    # Execute the trajectory
    #X = RK4(x0, m, tf)
    X=np.zeros([len(XYZ),3])
    #i=range(len(XYZ))
    #print(i)
    k=0
    for pp in XYZ:
    
        X[k,0]=pp[0]
        X[k,1]= pp[1]
        X[k,2]=pp[2]
        k=k+1
        

    #print(X)
    traj_set.append(X.copy())

    # Plotting repeatedly only in 1st and 2nd figure
    plt.figure(1)
    points.append(ax.scatter3D(X[:,0], X[:,1], X[:, 2], '-b', lw = 0.5, color=c[i]))
    ax.plot3D(X[:,0], X[:,1], X[:,2],
              # c = colors
              )

    #plt.axis('equal')

    # Plot after translation and roto dilatation
    #Z1=[]
    Z = X - X[0]
    #Z2 = Y-Y[0]
    #Z=[Z1,Z2]
    old_pos = Z[-1]
    R = roto_dilatation(old_pos, np.array([1,1,1]))
    Z = np.dot(Z, R.transpose())
    plt.figure(2)
    ax2.scatter3D(Z[:, 0], Z[:, 1], Z[:, 2], '-b', lw = 0.5)
    #plt.axis('equal')

#print(traj_set)


MP = dmp(n_dmps = 3, n_bfs = 50, K = 1000, alpha_s = 4.,rescale = 'rotodilatation', T = 2.)

MP.paths_regression(traj_set, t_set) # regression of all the paths, to make the red average line
x_track, _, _, _ = MP.rollout() ##UNDERSTAND THIS LINE, WHAT IS X_TRACK(regression line coordinates)

plt.figure(2)
ax2.scatter3D(x_track[:, 0], x_track[:, 1], x_track[:, 2], '-r',  color = "red", lw = 2)
#plt.xlabel(r'$x_12$')
#plt.ylabel(r'$x_22$')
#to mark the starting and ending point at (0,0) and (1,1)
ax2.scatter3D(0, 0, 0, '#k')
ax2.scatter3D(1, 1, 1,'Â§k')
plt.title('Scaled reference frame')


# Plot from an arbitrary position
theta = 2 * np.pi * np.random.rand()
rho = 1. - np.random.rand() / 5.
#choosing random starting point
MP.x_0 = rho * np.array([np.cos(theta), np.sin(theta), np.sin(4*theta)])
#Ending point
MP.x_goal = np.zeros(3)
x_track, _, _, _ = MP.rollout()
plt.figure(1)
ax.scatter3D(x_track[:, 0], x_track[:, 1], x_track[:, 2], '-r', color = "red",  lw = 2)
#plt.xlabel(r'$x_11$')
#plt.ylabel(r'$x_21$')
plt.title('Unscaled reference frame')
'''
# With noise
var = 0.0001
for i in range(num_traj): #num_traj
    traj_set[i] += np.random.randn(np.shape(traj_set[i])[0], np.shape(traj_set[i])[1]) * np.sqrt(var)

MP.paths_regression(traj_set, t_set)
MP_single = dmp(n_dmps = 2, n_bfs = 50, K = 1000, alpha_s = 4.,rescale = 'rotodilatation', T = 2.)
MP_single.imitate_path(x_des = traj_set[0], t_des = t_set[0])
x_track, dx_track, ddx_track, _ = MP.rollout()
MP_single.x_0 = np.zeros(2)
MP_single.x_goal = np.ones(2)
x_track_single, _, _, _ = MP_single.rollout()
plt.figure(3)
plt.plot(x_track[:,0], x_track[:,1], '-r')
plt.plot(x_track_single[:,0], x_track_single[:,1], '--g')
plt.plot(x_track[0][0], x_track[0][1], '.k', markersize = 10)
plt.plot(x_track[-1][0], x_track[-1][1], '*k', markersize = 10)
plt.xlabel(r'$x_13$', fontsize = 14)
plt.ylabel(r'$x_23$', fontsize = 14)
'''

plt.show()
